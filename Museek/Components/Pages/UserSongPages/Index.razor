@page "/usersongs"
@rendermode InteractiveServer
@using Microsoft.EntityFrameworkCore
@using Museek.Domain
@using Museek.Data
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IDbContextFactory<MuseekContext> DbFactory
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@attribute [Authorize]

<PageTitle>Library</PageTitle>

<div class="library-page">

    <h1 class="page-title">Library</h1>

    <div class="tabs">
        <span class="tab active">Liked</span>
    </div>

    <div class="top-actions">
        <div class="search-bar">
            <img src="images/search.png" class="search-icon" />
            <input type="text" placeholder="Search saved songs" @bind="searchText" />
        </div>
    </div>

    <div class="song-table">

        <div class="table-header">
            <span class="col-title name-col">Name</span>
            <span class="col-title small-col">Artist</span>
            <span class="col-title small-col">Date saved</span>
            <span class="col-title small-col">Actions</span>
        </div>

        @if (!FilteredSavedSongs.Any())
        {
            <div class="empty-row">
                You have not saved any songs yet.
            </div>
        }
        else
        {
            @foreach (var row in FilteredSavedSongs)
            {
                <div class="song-row">

                    <div class="song-main song-click"
                         role="button"
                         tabindex="0"
                         @onclick="@(() => PlaySavedSong(row))"
                         @onclick:stopPropagation="true"
                         @onkeydown="@((KeyboardEventArgs e) => OnSongKeyDown(e, row))">
                        <img src="@row.Song.Cover_Art" class="song-img" />
                        <div class="song-meta">
                            <span class="song-name">@row.Song.Title</span>
                            <span class="song-artist">@row.ArtistName</span>
                        </div>
                    </div>

                    <div class="song-stat">@row.ArtistName</div>

                    <div class="song-stat">
                        @row.UserSong.DateCreated.ToShortDateString()
                    </div>

                    <div class="song-actions">
                        <a href="@($"usersongs/edit?id={row.UserSong.Id}")">Edit</a> |
                        <a href="@($"usersongs/details?id={row.UserSong.Id}")">Details</a> |
                        <a href="@($"usersongs/delete?id={row.UserSong.Id}")">Remove</a>
                    </div>

                </div>
            }
        }
    </div>

</div>

@if (showPlayer)
{
    <div class="global-player-container">
        <section class="player-box">
            <button class="close-button" type="button" @onclick="ClosePlayer">×</button>

            <div class="player-left">
                <img id="songCover" src="@currentSong.Image" alt="Cover" />
                <div class="song-info">
                    <h4 id="songTitle">@currentSong.Title</h4>
                    <p id="songArtist">@currentSong.Artist</p>
                </div>

                <img src="@(isLiked ? "images/Liked.png" : "images/Like.png")"
                     alt="like"
                     class="icon-btn"
                     @onclick="@ToggleLike" />
            </div>

            <div class="player-controls">
                <input type="range" id="progressBar" min="0" max="100" value="@progress" @oninput="@SeekAudio" />
                <div class="control-buttons">
                    <img src="@(shuffleOn ? "images/shuffle.png" : "images/shuffleButton.png")"
                         alt="Shuffle"
                         class="control-icon"
                         @onclick="@ToggleShuffle" />
                    <img src="images/prevButton.png" alt="Previous" class="control-icon" @onclick="@PreviousSong" />
                    <img src="@(isPlaying ? "images/pauseButton.png" : "images/playButton.png")"
                         id="playPause"
                         alt="Play"
                         class="control-icon main"
                         @onclick="@TogglePlayPause" />
                    <img src="images/nextButton.png" alt="Next" class="control-icon" @onclick="@NextSong" />
                    <img src="@GetRepeatIcon()" alt="Repeat" class="control-icon" @onclick="@ToggleRepeat" />

                    <img src="images/rating.png"
                         alt="Rate"
                         class="control-icon rating-icon"
                         @onclick="@ToggleRatingPopover" />
                </div>
                <div class="time-display">
                    <span id="currentTime">@currentTime</span>
                    <span id="remainingTime">-@remainingTime</span>
                </div>
            </div>

            <div class="volume-control">
                <img src="images/volume.png" alt="Volume" class="control-icon" />
                <input type="range" id="volumeBar" min="0" max="100" value="@volume" @oninput="@ChangeVolume" />
            </div>

            <audio id="audioPlayer" src="@GetEncodedAudioPath(currentSong.AudioPath)"></audio>

            @if (showRatingPopover)
            {
                <div class="rating-popover-backdrop" @onclick="CloseRatingPopover">
                    <div class="rating-popover" @onclick:stopPropagation="true">
                        <button class="rating-close" type="button" @onclick="CloseRatingPopover">×</button>

                        <div class="rating-head">
                            <img class="rating-cover" src="@currentSong.Image" alt="Cover" />
                            <div class="rating-songmeta">
                                <div class="rating-title">@currentSong.Title</div>
                                <div class="rating-artist">@currentSong.Artist</div>
                            </div>
                        </div>

                        <div class="rating-stars">
                            @for (int i = 1; i <= 5; i++)
                            {
                                var star = i; /* IMPORTANT: avoid capturing the loop variable */
                                var isOn = ratingValue >= star;

                                <button type="button"
                                        class="star-btn"
                                        aria-label="Rate @star star"
                                        aria-pressed="@(isOn)"
                                        @onclick="@(() => SetRating(star))">
                                    <span class="star @(isOn ? "on" : "off")">★</span>
                                </button>
                            }
                        </div>

                        <div class="rating-field">
                            <label class="rating-label">Comment (optional)</label>
                            <textarea class="rating-textarea"
                                      placeholder="Add some notes"
                                      @bind="ratingComment"></textarea>
                        </div>

                        @if (!string.IsNullOrWhiteSpace(ratingError))
                        {
                            <div class="rating-error">@ratingError</div>
                        }

                        <div class="rating-actions">
                            <button class="rating-primary" type="button" @onclick="SaveRatingAsync">Rate</button>
                        </div>
                    </div>
                </div>
            }
        </section>
    </div>
}

@code {
    private MuseekContext context = default!;
    private string currentUserId = string.Empty;
    private string searchText = "";

    private List<SavedSongRow> savedSongs = new();

    private bool showPlayer = false;
    private bool isPlaying = false;

    // On /usersongs, songs are liked by definition.
    private bool isLiked = true;

    private double progress = 0;
    private double volume = 70;
    private string currentTime = "00:00";
    private string remainingTime = "00:00";

    private PlayerSong currentSong = new PlayerSong
    {
        SongId = 0,
        Title = "",
        Artist = "",
        Image = "",
        AudioPath = ""
    };

    // Playback state
    private List<PlayerSong> playbackQueue = new();
    private int currentIndex = -1;

    private bool shuffleOn = false;

    // repeatMode: 0 off, 1 repeat all, 2 repeat one
    private int repeatMode = 0;

    private readonly Random rng = new();
    private Stack<int> shuffleHistory = new();

    private DotNetObjectReference<object>? dotNetRef;
    private bool jsWired = false;

    // Rating UI state
    private bool showRatingPopover = false;
    private int ratingValue = 0; // 1..5
    private string ratingComment = "";
    private string ratingError = "";

    protected override async Task OnInitializedAsync()
    {
        context = DbFactory.CreateDbContext();

        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        currentUserId =
            user.FindFirst("userId")?.Value
            ?? user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value
            ?? string.Empty;

        if (string.IsNullOrWhiteSpace(currentUserId))
        {
            NavigationManager.NavigateTo("Account/Login");
            return;
        }

        savedSongs = await (
            from us in context.UserSong
            join s in context.Song on us.SongId equals s.Id
            join a in context.Artist on s.ArtistId equals a.Id into ag
            from a in ag.DefaultIfEmpty()
            where us.UserId == currentUserId
            orderby us.DateCreated descending
            select new SavedSongRow
            {
                UserSong = us,
                Song = s,
                ArtistName = a != null ? a.Name : "Unknown"
            }
        ).ToListAsync();

        playbackQueue = savedSongs.Select(r => new PlayerSong
        {
            SongId = r.Song.Id,
            Title = r.Song.Title ?? "Unknown Title",
            Artist = r.ArtistName ?? "Unknown",
            Image = r.Song.Cover_Art ?? "images/default-cover.png",
            AudioPath = r.Song.Audio_File ?? ""
        }).ToList();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initializeAudioPlayer");

            dotNetRef = DotNetObjectReference.Create<object>(this);
            jsWired = true;

            await EnsureEndedWiredAndRepeatApplied();
        }
    }

    private async Task EnsureEndedWiredAndRepeatApplied()
    {
        if (!jsWired || dotNetRef == null)
            return;

        await JSRuntime.InvokeVoidAsync("museekPlayer.wireEnded", dotNetRef);
        await JSRuntime.InvokeVoidAsync("museekPlayer.setLoop", repeatMode == 2);
    }

    private IEnumerable<SavedSongRow> FilteredSavedSongs =>
        string.IsNullOrWhiteSpace(searchText)
            ? savedSongs
            : savedSongs.Where(r =>
                (r.Song.Title ?? "").Contains(searchText, StringComparison.OrdinalIgnoreCase)
                || (r.ArtistName ?? "").Contains(searchText, StringComparison.OrdinalIgnoreCase));

    private async Task PlaySavedSong(SavedSongRow row)
    {
        var ordered = FilteredSavedSongs.ToList();

        playbackQueue = ordered.Select(r => new PlayerSong
        {
            SongId = r.Song.Id,
            Title = r.Song.Title ?? "Unknown Title",
            Artist = r.ArtistName ?? "Unknown",
            Image = r.Song.Cover_Art ?? "images/default-cover.png",
            AudioPath = r.Song.Audio_File ?? ""
        }).ToList();

        currentIndex = Math.Max(0, ordered.FindIndex(r => r.Song.Id == row.Song.Id));
        shuffleHistory.Clear();

        await PlayIndex(currentIndex, forcePlay: true);
    }

    private async Task PlayIndex(int index, bool forcePlay)
    {
        if (index < 0 || index >= playbackQueue.Count)
            return;

        currentIndex = index;

        var s = playbackQueue[currentIndex];
        currentSong = new PlayerSong
        {
            SongId = s.SongId,
            Title = s.Title,
            Artist = s.Artist,
            Image = s.Image,
            AudioPath = s.AudioPath
        };

        // This page only plays liked songs.
        isLiked = true;

        // Close rating UI when switching songs
        showRatingPopover = false;
        ratingError = "";

        showPlayer = true;

        StateHasChanged();

        await Task.Delay(50);

        await JSRuntime.InvokeVoidAsync("initializeAudioPlayer");
        await EnsureEndedWiredAndRepeatApplied();

        var encodedPath = GetEncodedAudioPath(currentSong.AudioPath);
        await JSRuntime.InvokeVoidAsync("loadAudio", encodedPath);

        if (!isPlaying || forcePlay)
        {
            isPlaying = true;
            await JSRuntime.InvokeVoidAsync("togglePlayPause");
        }
    }

    private async Task ClosePlayer()
    {
        if (isPlaying)
        {
            await JSRuntime.InvokeVoidAsync("togglePlayPause");
        }

        await JSRuntime.InvokeVoidAsync("loadAudio", "");

        isPlaying = false;
        showPlayer = false;

        showRatingPopover = false;
        ratingError = "";

        currentSong = new PlayerSong
        {
            SongId = 0,
            Title = "",
            Artist = "",
            Image = "",
            AudioPath = ""
        };

        currentIndex = -1;
        shuffleHistory.Clear();
        isLiked = true;
    }

    private async Task TogglePlayPause()
    {
        isPlaying = !isPlaying;
        await JSRuntime.InvokeVoidAsync("togglePlayPause");
    }

    // On /usersongs, clicking should remove from library (like delete).
    private async Task ToggleLike()
    {
        if (!isLiked)
            return;

        var songId = currentSong.SongId;
        if (songId <= 0)
            return;

        using var db = DbFactory.CreateDbContext();

        var link = await db.UserSong.FirstOrDefaultAsync(us =>
            us.UserId == currentUserId && us.SongId == songId);

        if (link == null)
            return;

        db.UserSong.Remove(link);
        await db.SaveChangesAsync();

        isLiked = false;

        savedSongs.RemoveAll(r => r.Song.Id == songId);
        playbackQueue.RemoveAll(s => s.SongId == songId);

        if (playbackQueue.Count == 0)
        {
            await ClosePlayer();
            StateHasChanged();
            return;
        }

        if (currentIndex >= playbackQueue.Count)
            currentIndex = playbackQueue.Count - 1;

        // Auto continue after removal.
        await PlayIndex(currentIndex, forcePlay: true);
        StateHasChanged();
    }

    private async Task PreviousSong()
    {
        if (playbackQueue.Count == 0 || currentIndex < 0)
            return;

        if (shuffleOn)
        {
            if (shuffleHistory.Count > 0)
            {
                var prev = shuffleHistory.Pop();
                await PlayIndex(prev, forcePlay: true);
                return;
            }
        }

        var nextIndex = currentIndex - 1;
        if (nextIndex < 0)
            nextIndex = playbackQueue.Count - 1;

        await PlayIndex(nextIndex, forcePlay: true);
    }

    private async Task NextSong()
    {
        if (playbackQueue.Count == 0 || currentIndex < 0)
            return;

        int nextIndex;

        if (shuffleOn)
        {
            shuffleHistory.Push(currentIndex);

            if (playbackQueue.Count == 1)
            {
                nextIndex = currentIndex;
            }
            else
            {
                do
                {
                    nextIndex = rng.Next(0, playbackQueue.Count);
                }
                while (nextIndex == currentIndex);
            }
        }
        else
        {
            nextIndex = currentIndex + 1;
            if (nextIndex >= playbackQueue.Count)
                nextIndex = 0;
        }

        await PlayIndex(nextIndex, forcePlay: true);
    }

    private async Task SeekAudio(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out double value))
        {
            progress = value;
            await JSRuntime.InvokeVoidAsync("seekAudio", value);
        }
    }

    private async Task ChangeVolume(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out double value))
        {
            volume = value;
            await JSRuntime.InvokeVoidAsync("changeVolume", value / 100);
        }
    }

    private void ToggleShuffle()
    {
        shuffleOn = !shuffleOn;
        shuffleHistory.Clear();
    }

    private async Task ToggleRepeat()
    {
        repeatMode++;
        if (repeatMode > 2)
            repeatMode = 0;

        if (jsWired)
        {
            await JSRuntime.InvokeVoidAsync("museekPlayer.setLoop", repeatMode == 2);
        }
    }

    private string GetRepeatIcon()
    {
        if (repeatMode == 1) return "images/repeat.png";
        if (repeatMode == 2) return "images/repeat1.png";
        return "images/repeatOff.png";
    }

    private async Task OnSongKeyDown(KeyboardEventArgs e, SavedSongRow row)
    {
        if (e.Key == "Enter" || e.Key == " ")
        {
            await PlaySavedSong(row);
        }
    }

    [JSInvokable]
    public async Task OnAudioEnded()
    {
        if (!showPlayer)
            return;

        if (repeatMode == 2)
        {
            await JSRuntime.InvokeVoidAsync("museekPlayer.restart");
            isPlaying = true;
            return;
        }

        if (playbackQueue.Count == 0 || currentIndex < 0)
            return;

        if (shuffleOn)
        {
            await NextSong();
            return;
        }

        var nextIndex = currentIndex + 1;
        if (nextIndex >= playbackQueue.Count)
        {
            if (repeatMode == 1)
            {
                nextIndex = 0;
            }
            else
            {
                await ClosePlayer();
                return;
            }
        }

        await PlayIndex(nextIndex, forcePlay: true);
    }

    private static string GetEncodedAudioPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            return "";

        var parts = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
        var encodedParts = parts.Select(p => Uri.EscapeDataString(p));
        return string.Join("/", encodedParts);
    }

    // Rating UI handlers
    private async Task ToggleRatingPopover()
    {
        if (currentSong.SongId <= 0)
            return;

        showRatingPopover = !showRatingPopover;
        ratingError = "";

        if (showRatingPopover)
        {
            await LoadExistingRatingAsync(currentSong.SongId);
        }
    }

    private void CloseRatingPopover()
    {
        showRatingPopover = false;
        ratingError = "";
    }

    private void SetRating(int value)
    {
        if (value < 1) value = 1;
        if (value > 5) value = 5;

        ratingValue = value;
        StateHasChanged();
    }

    private async Task LoadExistingRatingAsync(int songId)
    {
        ratingValue = 0;
        ratingComment = "";

        using var db = DbFactory.CreateDbContext();

        var existing = await db.Rating.FirstOrDefaultAsync(r =>
            r.UserId == currentUserId && r.SongId == songId);

        if (existing != null)
        {
            ratingValue = existing.Value;
            ratingComment = existing.Comment ?? "";
        }
    }

    private async Task SaveRatingAsync()
    {
        ratingError = "";

        if (currentSong.SongId <= 0)
            return;

        if (ratingValue < 1 || ratingValue > 5)
        {
            ratingError = "Please choose a rating.";
            return;
        }

        using var db = DbFactory.CreateDbContext();

        var songId = currentSong.SongId;

        var existing = await db.Rating.FirstOrDefaultAsync(r =>
            r.UserId == currentUserId && r.SongId == songId);

        if (existing == null)
        {
            var rating = new Rating
            {
                UserId = currentUserId,
                SongId = songId,
                Value = ratingValue,
                Comment = string.IsNullOrWhiteSpace(ratingComment) ? null : ratingComment.Trim(),
                DateCreated = DateTime.Now,
                DateUpdated = DateTime.Now,
                CreatedBy = currentUserId,
                UpdatedBy = currentUserId
            };

            db.Rating.Add(rating);
        }
        else
        {
            existing.Value = ratingValue;
            existing.Comment = string.IsNullOrWhiteSpace(ratingComment) ? null : ratingComment.Trim();
            existing.DateUpdated = DateTime.Now;
            existing.UpdatedBy = currentUserId;

            db.Rating.Update(existing);
        }

        await db.SaveChangesAsync();

        showRatingPopover = false;
        ratingError = "";
        StateHasChanged();
    }

    // Admin methods for later pages
    private async Task<double> GetAverageRatingForSongAsync(int songId)
    {
        using var db = DbFactory.CreateDbContext();

        var values = await db.Rating
            .Where(r => r.SongId == songId)
            .Select(r => r.Value)
            .ToListAsync();

        if (values.Count == 0)
            return 0;

        return values.Average();
    }

    private async Task<int> GetRatingCountForSongAsync(int songId)
    {
        using var db = DbFactory.CreateDbContext();
        return await db.Rating.CountAsync(r => r.SongId == songId);
    }

    private async Task<List<(int SongId, int Count)>> GetMostRatedSongsAsync(int top = 10)
    {
        using var db = DbFactory.CreateDbContext();

        var list = await db.Rating
            .GroupBy(r => r.SongId)
            .Select(g => new { SongId = g.Key, Count = g.Count() })
            .OrderByDescending(x => x.Count)
            .Take(top)
            .ToListAsync();

        return list.Select(x => (x.SongId, x.Count)).ToList();
    }

    private sealed class SavedSongRow
    {
        public UserSong UserSong { get; set; } = default!;
        public Song Song { get; set; } = default!;
        public string ArtistName { get; set; } = "";
    }

    private sealed class PlayerSong
    {
        public int SongId { get; set; }
        public string Title { get; set; } = "";
        public string Artist { get; set; } = "";
        public string Image { get; set; } = "";
        public string AudioPath { get; set; } = "";
    }

    public async ValueTask DisposeAsync()
    {
        if (dotNetRef != null)
        {
            dotNetRef.Dispose();
        }

        if (context != null)
        {
            await context.DisposeAsync();
        }
    }
}

<script>
    window.museekPlayer = window.museekPlayer || {
        wireEnded: function (dotNetRef) {
            try {
                const audio = document.getElementById("audioPlayer");
                if (!audio) return;

                if (audio._museekEndedHandler) {
                    audio.removeEventListener("ended", audio._museekEndedHandler);
                }

                audio._museekEndedHandler = function () {
                    dotNetRef.invokeMethodAsync("OnAudioEnded");
                };

                audio.addEventListener("ended", audio._museekEndedHandler);
            } catch { }
        },
        setLoop: function (on) {
            try {
                const audio = document.getElementById("audioPlayer");
                if (!audio) return;
                audio.loop = !!on;
            } catch { }
        },
        restart: function () {
            try {
                const audio = document.getElementById("audioPlayer");
                if (!audio) return;
                audio.currentTime = 0;
                audio.play();
            } catch { }
        }
    };
</script>
